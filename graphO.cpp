#include <Python.h>
#include<vector>
#include<iostream>
using namespace std;
double eps = 1e-9;
bool geq(double a, double b){return a - b >= -eps;}     //a >= b
bool leq(double a, double b){return b - a >= -eps;}     //a <= b
bool ge(double a, double b){return a - b > eps;}        //a > b
bool le(double a, double b){return b - a > eps;}        //a < b
bool eq(double a, double b){return abs(a - b) <= eps;}  //a == b
bool neq(double a, double b){return abs(a - b) > eps;}  //a != b

struct point{
    double x,y;
    int pos;
    point(): x(0), y(0){}
    point(double x, double y): x(x), y(y){}
	point(double x, double y , int pos): x(x), y(y), pos(pos){}
    point operator+(const point & p) const{return point(x + p.x, y + p.y);}
	point operator-(const point & p) const{return point(x - p.x, y - p.y);}
	point operator*(const double & k) const{return point(x * k, y * k);}
	point operator/(const double & k) const{return point(x / k, y / k);}
	point operator+=(const point & p){*this = *this + p; return *this;}
	point operator-=(const point & p){*this = *this - p; return *this;}
	point operator*=(const double & p){*this = *this * p; return *this;}
	point operator/=(const double & p){*this = *this / p; return *this;}
    double dot(const point & p) const{
        return x * p.x + y * p.y;
    }
    double cross(const point & p) const{
        return x * p.y - y * p.x;
    }
};
struct segment{
    point a,b;
    segment(point a, point b): a(a), b(b){}
};

vector<segment> generate_segments(vector<point> points){
    int sz = (int)points.size();
    vector<segment> segments;
    //Create all the segments with all the combinations of the points O(n(n-1)/2)
    for(int i = 0; i < sz ;i++){
        for(int j = i + 1; j < sz ;j++){
            segments.push_back(segment(points[i] , points[j]));
        }
    }
    return segments;
}
//function sign
int sgn(double x){
	if(ge(x, 0)) return 1;
	if(le(x, 0)) return -1;
	return 0;
}
//Know if a point is in a line
bool pointInLine(const point & a, const point & v, const point & p){
	//line a+tv, point p
	return eq((p - a).cross(v), 0);
}
//Know if a point is in a segment
bool pointInSegment(const point & a, const point & b, const point & p){
	//segment ab, point p
	return pointInLine(a, b - a, p) && leq((a - p).dot(b - p), 0);
}
//Know if two segments are disjoints
bool are_disjoints(const segment &s1 , const segment &s2){
    point a = s1.a;
    point b = s1.b;
    point c = s2.a;
    point d = s2.b;
    //segment ab, segment cd
    point v1 = b - a, v2 = d - c;
    int t = sgn(v1.cross(c - a)), u = sgn(v1.cross(d - a));
	if(t == u){
		if(t == 0){
			if(pointInSegment(a, b, c) || pointInSegment(a, b, d) || pointInSegment(c, d, a) || pointInSegment(c, d, b)){
                return false;
			}else{
                return true;
			}
		}else{
            return true;
		}
	}else{
        return (sgn(v2.cross(a - c)) != sgn(v2.cross(b - c))) == 0 ? true : false;
	}
}
/*
    Name   :  to_segments
    Input  :  A list of points P in the form [(x,y),(x,y)]
    Output :  A list of tuples with the positions of the points, with the form [(a,b),(a,b)] where a and b are the position in the list of the points, and every tuple is a segment, a to b
*/
static PyObject* graphO_to_segments(PyObject* self, PyObject* args){
    PyObject *pList;//The list of tuples
    PyObject *pItem;//A tuple of the list
    double x,y;//x and y values of the tuple
    vector<point> P;//The set of points
    vector<segment> P_;//The set of segments generated by P
    //Casting the Object to a PythonObject with form of list
    if (!PyArg_ParseTuple(args, "O!", &PyList_Type, &pList)) {
        return NULL;
    }
    //Check if the object is a list
    if (PyList_Check(pList)) {
        //Iterate all the elements of the list
        for(Py_ssize_t i = 0; i < PyList_Size(pList); i++) {
            //Get any element
			PyObject *value = PyList_GetItem(pList, i);
            //Parse it to a tuple
            PyArg_Parse(value, "O!", &PyTuple_Type, &pItem);
            //Check if is a tuple
            if (PyTuple_Check(pItem)) {
                //Get the first value of the tuple that corresponds to the x value
                x = PyFloat_AsDouble(PyTuple_GetItem(pItem,0));
                //Get the second value of the tuple that corresponds to the y value
                y = PyFloat_AsDouble(PyTuple_GetItem(pItem,1));
                //Push back in the vector a new point using the x y values
                P.push_back(point(x, y ,(int)i));
            }
		}
        //Generate all the segments
        P_ = generate_segments(P);
        //Create a objectlist
        PyObject* py_segments = PyList_New((int)P_.size());
        //Iterate all the segments
        for(int i = 0;i < (int) P_.size();i++){
            segment x_segment = P_[i];
            //Create a tuple with size of 2
            PyObject* py_tuple = PyTuple_New(2);
            //Set the first value of the tuple with the value of the position of the point a
            PyTuple_SetItem(py_tuple, 0 , Py_BuildValue("i",x_segment.a.pos));
            //Set the second value of the tuple with the value of the position of the point b
            PyTuple_SetItem(py_tuple, 1 , Py_BuildValue("i",x_segment.b.pos));
            //Set every element in the list with the value of the tuple
            PyList_SetItem(py_segments, i, py_tuple);
        }
        //Return the segments
        return py_segments;
    }
}
/*
    Name   :  to_disjointness_graph
    Input  :  A list of points P in the form [(x,y),(x,y)]
    Output :  A adyacency list of the graph with the form {0:[a,b,c]....}
*/
static PyObject* graphO_to_disjointness_graph(PyObject* self, PyObject* args){
    PyObject *pList;//The list of tuples
    PyObject *pItem;//A tuple of the list
    double x,y;//x and y values of the tuple
    vector<point> P;//The set of points
    vector<segment> P_;//The set of segments generated by P

    //Casting the Object to a PythonObject with form of list
    if (!PyArg_ParseTuple(args, "O!", &PyList_Type, &pList)) {
        return NULL;
    }
    //Check if the object is a list
    if (PyList_Check(pList)) {
        //Iterate all the elements of the list
        for(Py_ssize_t i = 0; i < PyList_Size(pList); i++) {
            //Get any element
			PyObject *value = PyList_GetItem(pList, i);
            //Parse it to a tuple
            PyArg_Parse(value, "O!", &PyTuple_Type, &pItem);
            //Check if is a tuple
            if (PyTuple_Check(pItem)) {
                //Get the first value of the tuple that corresponds to the x value
                x = PyFloat_AsDouble(PyTuple_GetItem(pItem,0));
                //Get the second value of the tuple that corresponds to the y value
                y = PyFloat_AsDouble(PyTuple_GetItem(pItem,1));
                //Push back in the vector a new point using the x y values
                P.push_back(point(x,y));
            }
		}
        P_ = generate_segments(P);
        int P_sz = (int)P_.size();
        PyObject *adj_list = PyDict_New();
        //Create the adjacency list in O(n*n) time complexity
        for(int i = 0;i < P_sz ;i++){
            PyObject* neighbors_list = PyList_New(0);
            for(int j = 0;j < P_sz ;j++){
                if (i != j)
                    if(are_disjoints(P_[i] , P_[j]))PyList_Append(neighbors_list,Py_BuildValue("i" , j));
            }
            PyDict_SetItem(adj_list,Py_BuildValue("i" , i), neighbors_list);

        }
        return adj_list;
    }
}
static PyMethodDef graphO_Methods[] = {
     {"to_disjointness_graph", graphO_to_disjointness_graph, METH_VARARGS, "Working"},
     {"to_segments", graphO_to_segments, METH_VARARGS, "Working"},
     {NULL, NULL, 0, NULL}
};

static struct PyModuleDef moduledef = {
        PyModuleDef_HEAD_INIT,
        "graphO",
        NULL,
        -1,
        graphO_Methods
};

PyMODINIT_FUNC PyInit_graphO(void){
     PyObject *module = PyModule_Create(&moduledef);
     return module;
}
