#include <Python.h>
#include<vector>
#include<iostream>
using namespace std;
double eps = 1e-9;
bool geq(double a, double b){return a-b >= -eps;}     //a >= b
bool leq(double a, double b){return b-a >= -eps;}     //a <= b
bool ge(double a, double b){return a-b > eps;}        //a > b
bool le(double a, double b){return b-a > eps;}        //a < b
bool eq(double a, double b){return abs(a-b) <= eps;}  //a == b
bool neq(double a, double b){return abs(a-b) > eps;}  //a != b

struct point{
    double x,y;
    int pos;
    point(): x(0), y(0){}
    point(double x, double y): x(x), y(y){}
	point(double x, double y , int pos): x(x), y(y), pos(pos){}
    point operator+(const point & p) const{return point(x + p.x, y + p.y);}
	point operator-(const point & p) const{return point(x - p.x, y - p.y);}
	point operator*(const double & k) const{return point(x * k, y * k);}
	point operator/(const double & k) const{return point(x / k, y / k);}
	point operator+=(const point & p){*this = *this + p; return *this;}
	point operator-=(const point & p){*this = *this - p; return *this;}
	point operator*=(const double & p){*this = *this * p; return *this;}
	point operator/=(const double & p){*this = *this / p; return *this;}
    double dot(const point & p) const{
        return x * p.x + y * p.y;
    }
    double cross(const point & p) const{
        return x * p.y - y * p.x;
    }
};
struct segment{
    point a,b;
    segment(point a, point b): a(a), b(b){}
};

vector<segment> generate_segments(vector<point> points){
    int sz = (int)points.size();
    vector<segment> segments;
    //Create all the segments with all the combinations of the points O(n(n-1)/2)
    for(int i = 0; i < sz ;i++){
        for(int j = i + 1; j < sz ;j++){
            segments.push_back(segment(points[i] , points[j]));
        }
    }
    return segments;
}
/*
    Name   :  to_segments
    Input  :  A list of points P in the form [(x,y),(x,y)]
    Output :  A list of tuples with the positions of the points, with the form [(a,b),(a,b)] where a and b are the position in the list of the points, and every tuple is a segment, a to b
*/
static PyObject* graphO_to_segments(PyObject* self, PyObject* args){
    PyObject *pList;//The list of tuples
    PyObject *pItem;//A tuple of the list
    double x,y;//x and y values of the tuple
    vector<point> P;//The set of points
    vector<segment> P_;//The set of segments generated by P

    //Casting the Object to a PythonObject with form of list
    if (!PyArg_ParseTuple(args, "O!", &PyList_Type, &pList)) {
        return NULL;
    }
    //Check if the object is a list
    if (PyList_Check(pList)) {
        //Iterate all the elements of the list
        for(Py_ssize_t i = 0; i < PyList_Size(pList); i++) {
            //Get any element
			PyObject *value = PyList_GetItem(pList, i);
            //Parse it to a tuple
            PyArg_Parse(value, "O!", &PyTuple_Type, &pItem);
            //Check if is a tuple
            if (PyTuple_Check(pItem)) {
                //Get the first value of the tuple that corresponds to the x value
                x = PyFloat_AsDouble(PyTuple_GetItem(pItem,0));
                //Get the second value of the tuple that corresponds to the y value
                y = PyFloat_AsDouble(PyTuple_GetItem(pItem,1));
                //Push back in the vector a new point using the x y values
                P.push_back(point(x, y ,(int)i));
            }
		}
        //Generate all the segments
        P_ = generate_segments(P);
        //Create a objectlist
        PyObject* py_segments = PyList_New((int)P_.size());
        //Iterate all the segments
        for(int i = 0;i < (int) P_.size();i++){
            segment x_segment = P_[i];
            //Create a tuple with size of 2
            PyObject* py_tuple = PyTuple_New(2);
            //Set the first value of the tuple with the value of the position of the point a
            PyTuple_SetItem(py_tuple, 0 , Py_BuildValue("i",x_segment.a.pos));
            //Set the second value of the tuple with the value of the position of the point b
            PyTuple_SetItem(py_tuple, 1 , Py_BuildValue("i",x_segment.b.pos));
            //Set every element in the list with the value of the tuple
            PyList_SetItem(py_segments, i, py_tuple);
        }
        //Return the segments
        return py_segments;
    }
}
/*
    Name   :  to_disjointness_graph
    Input  :  A list of points P in the form [(x,y),(x,y)]
    Output :  A adyacency list of the graph with the form {0:[a,b,c]....}
*/
static PyObject* graphO_to_disjointness_graph(PyObject* self, PyObject* args){
    PyObject *pList;//The list of tuples
    PyObject *pItem;//A tuple of the list
    double x,y;//x and y values of the tuple
    vector<point> P;//The set of points
    vector<segment> P_;//The set of segments generated by P

    //Casting the Object to a PythonObject with form of list
    if (!PyArg_ParseTuple(args, "O!", &PyList_Type, &pList)) {
        return NULL;
    }
    //Check if the object is a list
    if (PyList_Check(pList)) {
        //Iterate all the elements of the list
        for(Py_ssize_t i = 0; i < PyList_Size(pList); i++) {
            //Get any element
			PyObject *value = PyList_GetItem(pList, i);
            //Parse it to a tuple
            PyArg_Parse(value, "O!", &PyTuple_Type, &pItem);
            //Check if is a tuple
            if (PyTuple_Check(pItem)) {
                //Get the first value of the tuple that corresponds to the x value
                x = PyFloat_AsDouble(PyTuple_GetItem(pItem,0));
                //Get the second value of the tuple that corresponds to the y value
                y = PyFloat_AsDouble(PyTuple_GetItem(pItem,1));
                //Push back in the vector a new point using the x y values
                P.push_back(point(x,y));
            }
		}
        cout<<P.size()<<endl;
        P_ = generate_segments(P);
        //PyObject* python_val = PyList_New(PyList_Size(pList));
        PyObject* python_int = Py_BuildValue("i",(int)P_.size());
        //PyList_SetItem(python_val, i, python_int);
        return python_int;
    }
}
static PyMethodDef graphO_Methods[] = {
     {"to_disjointness_graph", graphO_to_disjointness_graph, METH_VARARGS, "Working"},
     {"to_segments", graphO_to_segments, METH_VARARGS, "Working"},
     {NULL, NULL, 0, NULL}
};

static struct PyModuleDef moduledef = {
        PyModuleDef_HEAD_INIT,
        "graphO",
        NULL,
        -1,
        graphO_Methods
};

PyMODINIT_FUNC PyInit_graphO(void){
     PyObject *module = PyModule_Create(&moduledef);
     return module;
}
